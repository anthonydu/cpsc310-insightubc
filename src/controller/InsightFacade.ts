import * as fs from "fs-extra";
import JSZip from "jszip";

import {
	IInsightFacade,
	InsightDataset,
	InsightDatasetKind,
	InsightError,
	InsightResult,
	NotFoundError,
} from "./IInsightFacade";
import {QueryManager} from "./queryManager";
import {Building, GeoResponse, PersistDataset, Room, Section} from "./queryTypes";
import {parse as parse5} from "parse5";
import {NodePlus} from "./NodePlus";
import http from "node:http";

/**
 * This is the main programmatic entry point for the project.
 * Method documentation is in IInsightFacade
 *
 */
const persistFile = "data/datasets.json";

export default class InsightFacade implements IInsightFacade {
	private static async readPersist() {
		try {
			return await fs.readJson(persistFile);
		} catch {
			return [];
		}
	}

	// Given an address, return geo response
	private static async fetchGeo(address: string): Promise<GeoResponse> {
		// Generated by GitHub Copilot
		return new Promise((resolve) => {
			const req = http.get(
				`http://cs310.students.cs.ubc.ca:11316/api/v1/project_team142/${address}`,
				(res: any) => {
					let data = "";
					res.on("data", (chunk: any) => {
						data += chunk;
					});
					res.on("end", () => {
						try {
							resolve(JSON.parse(data));
						} catch {
							resolve({error: "JSON parse error"});
						}
					});
				}
			);
			req.on("error", () => {
				resolve({error: "HTTP request error"});
			});
		});
	}

	// Given the content of index.htm, return a list of buildings
	private static async parseBuildings(html: string): Promise<Building[]> {
		const buildings: Building[] = [];
		try {
			const document = new NodePlus(parse5(html));
			const tables = document.getElementsBy("tagName", "table");
			const buildingTable = tables.filter((table) => {
				return table.getElementsBy("className", "views-field-field-building-code").length > 0;
			})[0];
			const tbody = buildingTable.getElementsBy("tagName", "tbody")[0];
			const rows = tbody.getElementsBy("tagName", "tr");
			await Promise.all(
				rows.map(async (row) => {
					const titleNode = row.getElementsBy("className", "views-field-title")[0];
					const address = row.getElementsBy("className", "views-field-field-building-address")[0].getText();
					const geoResponse: GeoResponse = await InsightFacade.fetchGeo(address);
					if (geoResponse.error) {
						throw new InsightError(`GeoResponse error for ${address}: ${geoResponse.error}`);
					}
					buildings.push({
						fullname: titleNode.getElementsBy("tagName", "a")[0].getText(),
						shortname: row.getElementsBy("className", "views-field-field-building-code")[0].getText(),
						address,
						lat: parseFloat(geoResponse.lat as unknown as string),
						lon: parseFloat(geoResponse.lon as unknown as string) ,
						href: titleNode.getElementsBy("tagName", "a")[0].getAttributes().href,
					});
				})
			);
		} catch (e) {
			throw new InsightError(`Parse index.htm failed: ${e}`);
		}
		if (buildings.length === 0) {
			throw new InsightError("No valid buildings.");
		}
		return buildings;
	}

	// Given the content of a building file, return a list of rooms
	// The building object is used to fill in the building fields of the rooms
	private static parseRoom(html: string, building: Building): Room[] {
		const rooms: Room[] = [];
		try {
			const document = new NodePlus(parse5(html));
			const tables = document.getElementsBy("tagName", "table");
			const roomTable = tables.filter((table) => {
				return table.getElementsBy("className", "views-field-field-room-number").length > 0;
			})[0];
			if (!roomTable) {
				return [];
			}
			const tbody = roomTable.getElementsBy("tagName", "tbody")[0];
			const rows = tbody.getElementsBy("tagName", "tr");
			rows.forEach((row) => {
				const roomNumberNode = row.getElementsBy("className", "views-field-field-room-number")[0];
				const roomNumber = roomNumberNode.getElementsBy("tagName", "a")[0].getText();
				rooms.push({
					...building,
					number: roomNumber,
					name: building.shortname + "_" + roomNumber,
					seats: parseInt(row.getElementsBy("className", "views-field-field-room-capacity")[0].getText(), 10),
					type: row.getElementsBy("className", "views-field-field-room-type")[0].getText(),
					furniture: row.getElementsBy("className", "views-field-field-room-furniture")[0].getText(),
					href: roomNumberNode.getElementsBy("tagName", "a")[0].getAttributes().href,
				});
			});
		} catch (e) {
			throw new InsightError(`Parse room failed: ${e}`);
		}
		return rooms;
	}

	// Given a list of json file strings, return a list of sections
	private static parseSections(jsons: string[]): Section[] {
		const sections: Section[] = [];
		for (const json of jsons) {
			try {
				for (const section of JSON.parse(json).result) {
					sections.push({
						uuid: String(section.id),
						id: section.Course as string,
						title: section.Title as string,
						instructor: section.Professor as string,
						dept: section.Subject as string,
						year: section.Section === "overall" ? 1900 : parseInt(section.Year, 10),
						avg: parseFloat(section.Avg),
						pass: parseInt(section.Pass, 10),
						fail: parseInt(section.Fail, 10),
						audit: parseInt(section.Audit, 10),
					} as Section);
				}
			} catch {
				continue;
			}
		}
		return sections;
	}

	// Given the content of a zip file, return a list of sections
	// Uses parseSections to parse the json files in the zip
	private static async processSections(zipContent: string): Promise<Section[]> {
		const zip = new JSZip();
		let sections: Section[];
		try {
			const courses = await zip.loadAsync(zipContent, {base64: true});
			if (!courses.files["courses/"]) {
				throw new InsightError("No courses folder.");
			}
			const files: Array<Promise<string>> = [];
			for (const file of Object.values(courses.files)) {
				files.push(file.async("string"));
			}
			sections = await this.parseSections(await Promise.all(files));
		} catch (e) {
			throw new InsightError(`Process sections failed: ${e}`);
		}
		if (sections.length === 0) {
			throw new InsightError("No valid sections.");
		}
		return sections;
	}

	// Given the base64 content of a zip file, return a list of rooms
	// Uses parseBuildings to parse the index.htm file in the zip
	// Uses parseRoom to parse the building files in the zip (only files linked from index.htm are parsed)
	private static async processRooms(zipContent: string): Promise<Room[]> {
		const zip = new JSZip();
		let rooms: Room[][] = [];
		try {
			const campus = await zip.loadAsync(zipContent, {base64: true});
			if (!campus.file("index.htm")) {
				throw new InsightError("No index.htm file.");
			}
			const buildingsFolder = campus.folder("campus/discover/buildings-and-classrooms/");
			if (!buildingsFolder) {
				throw new InsightError("No campus/discover/buildings-and-classrooms folder.");
			}
			const buildings = await this.parseBuildings(await campus.files["index.htm"].async("string"));
			await Promise.all(
				buildings.map(async (building) => {
					const buildingFile = campus.file(building.href.split("./").slice(-1)[0]);
					if (!buildingFile) {
						return;
					}
					rooms.push(await this.parseRoom(await buildingFile.async("string"), building));
				})
			);
		} catch (e) {
			throw new InsightError(`Process rooms failed: ${e}`);
		}
		if (rooms.length === 0) {
			throw new InsightError("No valid rooms.");
		}
		return rooms.flat();
	}

	private static idInvalid(id: string) {
		return id.includes("_") || id.trim() === "";
	}

	public async addDataset(id: string, content: string, kind: InsightDatasetKind): Promise<string[]> {
		let datasets: PersistDataset[] = await InsightFacade.readPersist();
		if (InsightFacade.idInvalid(id) || datasets.some((dataset) => dataset.id === id)) {
			throw new InsightError("Invalid id.");
		}
		let data: Section[] | Room[];
		if (kind === InsightDatasetKind.Sections) {
			data = await InsightFacade.processSections(content);
		} else if (kind === InsightDatasetKind.Rooms) {
			data = await InsightFacade.processRooms(content);
		} else {
			throw new InsightError("Invalid kind.");
		}
		datasets.push({id, kind, numRows: data.length, data});
		await fs.outputJSON(persistFile, datasets);
		return datasets.map((dataset) => dataset.id);
	}

	public async removeDataset(id: string): Promise<string> {
		let datasets: PersistDataset[] = await InsightFacade.readPersist();
		if (InsightFacade.idInvalid(id)) {
			throw new InsightError("Invalid id.");
		}
		if (!datasets.some((dataset) => dataset.id === id)) {
			throw new NotFoundError("Dataset not found.");
		}
		datasets = datasets.filter((dataset) => dataset.id !== id);
		await fs.outputJSON(persistFile, datasets);
		return id;
	}

	public async performQuery(query: unknown): Promise<InsightResult[]> {
		const queryManager: QueryManager = new QueryManager(query);
		return queryManager.execute();
	}

	public async listDatasets(): Promise<InsightDataset[]> {
		const datasets: PersistDataset[] = await InsightFacade.readPersist();
		return datasets.map((dataset) => ({
			id: dataset.id,
			kind: dataset.kind,
			numRows: dataset.numRows,
		}));
	}
}
